(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{228:function(_,v,a){"use strict";a.r(v);var t=a(0),i=Object(t.a)({},(function(){var _=this.$createElement;this._self._c;return this._m(0)}),[function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("div",{staticClass:"content"},[a("p",[_._v("金句：")]),_._v(" "),a("ul",[a("li",[_._v("软件设计最大的难题就是应对需求的变化，但是纷繁复杂的需求变化又是不可预料的。我们要为不可预料的事情做好准备，这本身就是一件非常痛苦的事情")]),_._v(" "),a("li",[_._v("写高级语言程序不是像我们前辈写二进制代码、汇编一样，写完基本上就自己能看懂，别人看就跟看天书一样，现在的高级语言，要像写中文汉字一样，你写的，别人也要能看懂。")])]),_._v(" "),a("h1",{attrs:{id:"设计模式之禅-这本书-的读书笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式之禅-这本书-的读书笔记","aria-hidden":"true"}},[_._v("#")]),_._v(" << 设计模式之禅 >> 这本书 的读书笔记")]),_._v(" "),a("h1",{attrs:{id:"第一章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一章","aria-hidden":"true"}},[_._v("#")]),_._v(" 第一章")]),_._v(" "),a("h2",{attrs:{id:"单一职责原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则","aria-hidden":"true"}},[_._v("#")]),_._v(" 单一职责原则")]),_._v(" "),a("p",[_._v("应该有且仅有一个原因引起类的变更")]),_._v(" "),a("ul",[a("li",[_._v("实现细节：\n"),a("ol",[a("li",[_._v("如果一个接口包含了两个职责，而且这两个职责的变化不相互影响，那就考虑拆分成两个接口")])])]),_._v(" "),a("li",[_._v("优点：\n"),a("ol",[a("li",[_._v("类的复杂性降低，实现什么职责都有清晰明确的定义；")]),_._v(" "),a("li",[_._v("可读性提高，复杂性降低，那当然可读性提高了；")]),_._v(" "),a("li",[_._v("可维护性提高，可读性提高，那当然更容易维护了；")]),_._v(" "),a("li",[_._v("变更引起的风险降低")])])])]),_._v(" "),a("h2",{attrs:{id:"里氏替换原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则","aria-hidden":"true"}},[_._v("#")]),_._v(" 里氏替换原则")]),_._v(" "),a("p",[_._v("所有引用基类的地方必须能透明地使用其子类的对象，即子类可以替换基类")]),_._v(" "),a("h2",{attrs:{id:"依赖倒置原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则","aria-hidden":"true"}},[_._v("#")]),_._v(" 依赖倒置原则")]),_._v(" "),a("p",[_._v("抽象不应依赖细节，减少类之间的相互依赖")]),_._v(" "),a("ul",[a("li",[_._v("实现细节：\n"),a("ol",[a("li",[_._v("每个类尽量都要有 "),a("code",[_._v("接口")]),_._v(" 和 "),a("code",[_._v("抽象类")]),_._v("，或抽象类和接口两者都具备")]),_._v(" "),a("li",[_._v("变量的表面类型 尽量是 接口或抽象类")])])]),_._v(" "),a("li",[_._v("优点：\n"),a("ol",[a("li",[_._v("通过使用依赖倒置原则设计的接口或抽象类对实现类进行约束，可以减少需求变化引起的工作量剧增的情况")]),_._v(" "),a("li",[_._v("使人员变动对 项目扩展和维护 的影响 降到最低")])])])]),_._v(" "),a("h2",{attrs:{id:"接口隔离原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则","aria-hidden":"true"}},[_._v("#")]),_._v(" 接口隔离原则")]),_._v(" "),a("p",[_._v("客户端不应依赖它不需要的接口"),a("br"),_._v("\n类之间的依赖关系应建立在最小的接口上")]),_._v(" "),a("ul",[a("li",[_._v("实现细节\n"),a("ol",[a("li",[_._v("拆分需要区分的功能 为多个接口，按需组合（实现）")]),_._v(" "),a("li",[_._v("考虑接口隔离原则时，首先需要满足单一职责原则")])])]),_._v(" "),a("li",[_._v("优点")]),_._v(" "),a("li",[_._v("缺点\n"),a("ol",[a("li",[_._v("接口的设计粒度越细，系统越灵活，可扩展性越高，但同时会导致结构的复杂化，开发难度增加，可维护性降低，所以接口设计要适度\n"),a("code",[_._v("尽量使用多个专门的接口")])])])])]),_._v(" "),a("h2",{attrs:{id:"迪米特法则-（最少知识原则）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则-（最少知识原则）","aria-hidden":"true"}},[_._v("#")]),_._v(" 迪米特法则 （最少知识原则）")]),_._v(" "),a("p",[_._v("一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立，即在控制系统中 常说的模块间 "),a("code",[_._v("高内聚，低耦合")]),_._v(" 原则")]),_._v(" "),a("ul",[a("li",[_._v("实现细节\n"),a("ol",[a("li",[_._v("尽量减少一个类公开的 public 方法，将实现细节内聚在类中")])])])]),_._v(" "),a("h2",{attrs:{id:"开放封闭原则-————-终极原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开放封闭原则-————-终极原则","aria-hidden":"true"}},[_._v("#")]),_._v(" 开放封闭原则 ———— 终极原则")]),_._v(" "),a("p",[_._v("一个软件实体如 类，模块，函数应该 对扩展开放，对修改关闭")]),_._v(" "),a("ul",[a("li",[_._v("实现细节\n以上的五种设计模式都是这一条的具体实现规则")])]),_._v(" "),a("h1",{attrs:{id:"_23-个设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-个设计模式","aria-hidden":"true"}},[_._v("#")]),_._v(" 23 个设计模式")]),_._v(" "),a("h2",{attrs:{id:"_1-单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-单例模式","aria-hidden":"true"}},[_._v("#")]),_._v(" 1. 单例模式")]),_._v(" "),a("p",[_._v("一个类只会产生一个实例，或固定个数个实例（扩展后）")]),_._v(" "),a("h2",{attrs:{id:"_2-工厂方法模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-工厂方法模式","aria-hidden":"true"}},[_._v("#")]),_._v(" 2. 工厂方法模式")]),_._v(" "),a("p",[_._v("定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类")]),_._v(" "),a("h2",{attrs:{id:"_3-抽象工厂模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-抽象工厂模式","aria-hidden":"true"}},[_._v("#")]),_._v(" 3. 抽象工厂模式")]),_._v(" "),a("h2",{attrs:{id:"_4-模板方法模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-模板方法模式","aria-hidden":"true"}},[_._v("#")]),_._v(" 4. 模板方法模式")]),_._v(" "),a("p",[_._v("定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改\n变一个算法的结构即可重定义该算法的某些特定步骤")]),_._v(" "),a("ul",[a("li",[_._v("实现细节\n"),a("ol",[a("li",[_._v("在父类中预定义好模板方法的执行结构（调用其他基本方法），这些子方法在子类定义时给值，使得子类可以(部分)重定义模板方法中的特定步骤")]),_._v(" "),a("li",[_._v("模板方法一般不允许被覆写")]),_._v(" "),a("li",[_._v("抽象模板中的基本方法尽量设计为 protected 类型，以符合迪米特法则")]),_._v(" "),a("li",[_._v("实际使用中，使用 "),a("code",[_._v("模板方法+基本方法+钩子（传入模板方法配置）")]),_._v(" 的模式，来增加一部分扩展性")])])]),_._v(" "),a("li",[_._v("优点\n"),a("ol",[a("li",[_._v("封装不变部分，扩展可变部分")]),_._v(" "),a("li",[_._v("提取公共部分代码，便于维护")]),_._v(" "),a("li",[_._v("行为由父类控制，子类实现")]),_._v(" "),a("li",[_._v("父类要使用子类的方法？ 这本是设计缺陷，但可通过 建造者模式 实现")])])]),_._v(" "),a("li",[_._v("缺点\n模板方法模式颠倒了先抽象再具体的一般设计思路，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度")])]),_._v(" "),a("h2",{attrs:{id:"_5-建造者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-建造者模式","aria-hidden":"true"}},[_._v("#")]),_._v(" 5. 建造者模式")]),_._v(" "),a("p",[_._v("将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示")]),_._v(" "),a("ul",[a("li",[_._v("实现细节\n"),a("ol",[a("li",[_._v("产品类：通常是实现了模板方法模式，也就是有模板方法和基本方法")]),_._v(" "),a("li",[_._v("建造者（抽象类，实现类）：规范产品的组建，实现抽象类定义的所有方法，有几个产品类，就有几个具体建造者")]),_._v(" "),a("li",[_._v("导演类：封装的作用，避免高层模块深入到建造者内部的实现类")]),_._v(" "),a("li",[_._v("建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。")])])]),_._v(" "),a("li",[_._v("优点\n"),a("ol",[a("li",[_._v("使用建造者模式可以使客户端不必知道产品内部组成的细节")]),_._v(" "),a("li",[_._v("建造者独立，容易扩展")]),_._v(" "),a("li",[_._v("由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生影响")])])]),_._v(" "),a("li",[_._v("缺点")])]),_._v(" "),a("h2",{attrs:{id:"_6-代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-代理模式","aria-hidden":"true"}},[_._v("#")]),_._v(" 6. 代理模式")]),_._v(" "),a("p",[_._v("为其他对象提供一种代理以控制对这个对象的访问\n普通代理：\n强制代理：\n动态代理：代理的类在代码运行时才创建，并在之后使用")]),_._v(" "),a("ul",[a("li",[_._v("实现细节\n"),a("ol",[a("li",[_._v("1")])])]),_._v(" "),a("li",[_._v("优点\n"),a("ol",[a("li",[_._v("职责清晰")]),_._v(" "),a("li",[_._v("高扩展性")]),_._v(" "),a("li",[_._v("智能化")])])])]),_._v(" "),a("h2",{attrs:{id:"other-tips"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#other-tips","aria-hidden":"true"}},[_._v("#")]),_._v(" Other Tips")]),_._v(" "),a("ol",[a("li",[_._v("相较于 interface 是 class 的接口（类接口），其实 class 也算是一种 Object 的接口，称之为 实例接口")]),_._v(" "),a("li")]),_._v(" "),a("p",[_._v("读书可以跳着看，回过去再看，兴趣第一，全局理解为主，不要卡在一处磨掉自己的耐心")])])}],!1,null,null,null);v.default=i.exports}}]);